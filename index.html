<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>main</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        background-color: #ffffff;
        color: #a0a0a0;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
    div.sourceCode
      { color: #1f1c1b; background-color: #ffffff; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #1f1c1b; } /* Normal */
    code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
    code span.an { color: #ca60ca; } /* Annotation */
    code span.at { color: #0057ae; } /* Attribute */
    code span.bn { color: #b08000; } /* BaseN */
    code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
    code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #924c9d; } /* Char */
    code span.cn { color: #aa5500; } /* Constant */
    code span.co { color: #898887; } /* Comment */
    code span.cv { color: #0095ff; } /* CommentVar */
    code span.do { color: #607880; } /* Documentation */
    code span.dt { color: #0057ae; } /* DataType */
    code span.dv { color: #b08000; } /* DecVal */
    code span.er { color: #bf0303; text-decoration: underline; } /* Error */
    code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
    code span.fl { color: #b08000; } /* Float */
    code span.fu { color: #644a9b; } /* Function */
    code span.im { color: #ff5500; } /* Import */
    code span.in { color: #b08000; } /* Information */
    code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
    code span.op { color: #1f1c1b; } /* Operator */
    code span.ot { color: #006e28; } /* Other */
    code span.pp { color: #006e28; } /* Preprocessor */
    code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
    code span.sc { color: #3daee9; } /* SpecialChar */
    code span.ss { color: #ff5500; } /* SpecialString */
    code span.st { color: #bf0303; } /* String */
    code span.va { color: #0057ae; } /* Variable */
    code span.vs { color: #bf0303; } /* VerbatimString */
    code span.wa { color: #bf0303; } /* Warning */
  </style>
  <link rel="stylesheet" href="latex2html.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#ch:into" id="toc-ch:into">Parte 1</a>
<ul>
<li><a href="#struttura-del-sistema-ad-attori-e-descrizione-operativa"
id="toc-struttura-del-sistema-ad-attori-e-descrizione-operativa">Struttura
del Sistema ad Attori e Descrizione Operativa</a>
<ul>
<li><a href="#livello-1-boss" id="toc-livello-1-boss">Livello 1:
Boss</a></li>
<li><a href="#livello-2-pm-project-manager"
id="toc-livello-2-pm-project-manager">Livello 2: Pm (Project
Manager)</a></li>
<li><a href="#livello-3-employee" id="toc-livello-3-employee">Livello 3:
Employee</a></li>
<li><a href="#interazione-tra-gli-attori"
id="toc-interazione-tra-gli-attori">Interazione tra gli Attori</a></li>
</ul></li>
</ul></li>
<li><a href="#ch:into" id="toc-ch:into">Part 2</a>
<ul>
<li><a href="#struttura-e-gestione-code"
id="toc-struttura-e-gestione-code">Struttura e gestione code</a></li>
</ul></li>
<li><a href="#ch:into" id="toc-ch:into">Part 3</a>
<ul>
<li><a href="#introduzione-e-struttura"
id="toc-introduzione-e-struttura">Introduzione e struttura</a>
<ul>
<li><a href="#server" id="toc-server">Server</a></li>
<li><a href="#modifiche-client" id="toc-modifiche-client">Modifiche
Client</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<div class="titlepage">
<div class="center">
<p><span>University of Bologna<br />
DISI</span><br />
</p>
<p>Assignement 3 report:</p>
<p>Message Oriented and Distributed Systems</p>
<p> <br />
<span> Matteo Santoro </span><br />
<span> <em>Supervisor:</em> Alessandro Ricci </span><br />
</p>
<p>2024-12-09</p>
</div>
</div>
<h1 id="ch:into">Parte 1</h1>
<p>La soluzione ad attori del problema degli Assignement precedenti è
stata implementata in java, utilizzando la libreria Akka.</p>
<h2
id="struttura-del-sistema-ad-attori-e-descrizione-operativa">Struttura
del Sistema ad Attori e Descrizione Operativa</h2>
<p>La gerarchia è composta da tre principali livelli di attori:
<strong>Boss</strong>, <strong>Pm</strong> e <strong>Employee</strong>,
ciascuno con ruoli e responsabilità ben definiti.</p>
<h3 id="livello-1-boss">Livello 1: Boss</h3>
<p>L’attore <strong>Boss</strong> è la radice della gerarchia ed è
responsabile dell’intero processo di gestione dei task. Riceve il
percorso di una directory (<code>directoryPath</code>) e popola una
lista di compiti (<code>pathList</code>) utilizzando la funzione
<code>Utils.populateListOfPaths</code>. Dopo aver suddiviso i compiti in
sottogruppi basandosi sul numero di lavoratori disponibili, il
<strong>Boss</strong> invia un messaggio <code>Pm.Order</code> al suo
subordinato <strong>Pm</strong>, specificando:</p>
<ul>
<li><p>La directory di lavoro.</p></li>
<li><p>I compiti da eseguire suddivisi in blocchi.</p></li>
<li><p>Eventuali riferimenti per risposte future.</p></li>
</ul>
<p>Inoltre, il <strong>Boss</strong> monitora l’elaborazione tramite i
report inviati dagli <strong>Employee</strong>, aggiornando i dati
attraverso un’interfaccia che organizza i risultati dei task. Questo lo
rende il punto centrale della raccolta dei risultati.</p>
<h3 id="livello-2-pm-project-manager">Livello 2: Pm (Project
Manager)</h3>
<p>Il <strong>Pm</strong> agisce come intermediario tra il
<strong>Boss</strong> e i lavoratori effettivi
(<strong>Employee</strong>). Al momento della creazione, genera una
serie di attori <strong>Employee</strong>, il cui numero è specificato
dalla costante <code>NUMBER_OF_WORKERS</code>. Il <strong>Pm</strong>
riceve i compiti dal <strong>Boss</strong> e li assegna ai suoi
lavoratori utilizzando il messaggio <code>Ordered</code>, suddividendo
equamente i task.</p>
<p>Durante l’elaborazione, il <strong>Pm</strong> riceve i report dagli
<strong>Employee</strong> tramite messaggi di tipo
<code>Employee.Report</code> e li inoltra al <strong>Boss</strong>.</p>
<p>In caso di comandi globali come la pausa (<code>StopMsg</code>) o la
ripresa (<code>ResumeMsg</code>), il <strong>Pm</strong> inoltra i
messaggi a tutti gli <strong>Employee</strong>, garantendo un controllo
centralizzato.</p>
<h3 id="livello-3-employee">Livello 3: Employee</h3>
<p>Gli attori <strong>Employee</strong> rappresentano i lavoratori del
sistema. Ognuno riceve un insieme di compiti dal <strong>Pm</strong> e
li elabora uno alla volta. Le principali caratteristiche di un
<strong>Employee</strong> includono:</p>
<ul>
<li><p><strong>Gestione Asincrona dei Task:</strong> I task vengono
elaborati utilizzando una funzione di utilità
(<code>Utils.linesWithBufferInputStream</code>) e i risultati vengono
inviati tramite un report al mittente (di norma il
<strong>Pm</strong>).</p></li>
<li><p><strong>Pausa e Ripresa:</strong> Gli <strong>Employee</strong>
possono fermare l’elaborazione dei task tramite il messaggio
<code>StopMsg</code> e riprenderla tramite <code>ResumeMsg</code>.
Questa capacità migliora la resilienza del sistema e consente una
gestione flessibile dei lavoratori.</p></li>
<li><p><strong>Chiusura Ciclica dei Task:</strong> Utilizzano un
iteratore (<code>taskIterator</code>) per avanzare nel ciclo di compiti
assegnati e inviano notifiche al completamento.</p></li>
</ul>
<h3 id="interazione-tra-gli-attori">Interazione tra gli Attori</h3>
<p>L’interazione tra gli attori è basata su un flusso di messaggi ben
definito:</p>
<ol>
<li><p><strong>Boss → Pm:</strong> Invio dei compiti tramite
<code>Pm.Order</code>.</p></li>
<li><p><strong>Pm → Employee:</strong> Assegnazione dei task tramite
<code>Ordered</code>.</p></li>
<li><p><strong>Employee → Pm:</strong> Invio dei risultati dei task
tramite <code>Employee.Report</code>.</p></li>
<li><p><strong>Pm → Boss:</strong> Trasmissione dei report degli
<strong>Employee</strong>.</p></li>
</ol>
<p>Questa struttura modulare rende il sistema scalabile e facile da
mantenere, poiché ogni livello si occupa esclusivamente di un insieme
ben definito di responsabilità.</p>
<p><img src="report/img/chaGpt-graph.png" style="width:15cm"
alt="image" /><br />
</p>
<h1 id="ch:into">Part 2</h1>
<p>La seconda parte dell’assignement consisteva nell’implementazione di
una versoine di Pixel art, un software per la colorazione collaborativa
di una matrice, tramite un gestore di scambi di messaggi. Le modifiche
sulla propria matrice e ricezione di quelle degli altri utenti devono
essere visibili sulla propria "versione locale" senza dover condividere
nessuna porzione di memoria.</p>
<h2 id="struttura-e-gestione-code">Struttura e gestione code</h2>
<p>Durante la creazione di ogni client viene attributo un clientID
randomico. Ogni messaggio viene inviato sullo stesso
<strong>Exchange</strong> che in questo contesto è di tipo Topic, per
poter inviare messaggi di determinati contesti in code separate. I
contesti di interesse per questo esercizio, e i loro utilizzi sono i
seguenti:</p>
<ul>
<li><p><strong>Mouse</strong>: scambio della posizione dei puntatori di
tutti i client collegati alla rete per poterli visualizzare
contemporaneamente.</p></li>
<li><p><strong>Brush</strong>: notifica di cambio colore real-time del
brush dei client.</p></li>
<li><p><strong>Color</strong>: evento di colorazione di un pixel dei
client.</p></li>
<li><p><strong>History</strong>: ???? storia di eventi di colorazione
pixel per i nuovi client che si collegano in un momento
successivo.</p></li>
<li><p><strong>Exit</strong>: ???? notifica di uscita di un client e
rimozione del brush.</p></li>
</ul>
<p>La pubblicazione di messaggi in queste code è, giustamente, collegata
agli eventi che vogliono catturare. Prendendo ad esempio il cambio di
colore di un brush. La classe di gestione dei pennelli è stata estesa
aggiungendo a ciascun brush l’identificatore del proprio client. Ogni
messaggio pubblicato sulla coda dei pennelli viene intercettato e
passato a questa classe, che contiene una lista dei brush e identifica
quello che ha cambiato colore, aggiornandolo nel client locale che ha
ricevuto il messaggio. Nello stesso modo l’evento di modifica di colore
notifica questo evento pubblicando un messaggio che contiene le
informazioni necessarie agli altri client per modificare la grafica.
visto la semplicità del contesto i messaggi contengono tutte le
informazioni, come identificatore e colore, in una stringa separate da
un carattere speciale, in questo caso il ’_’.</p>
<p>Un ragionamento analogo è stato fatto per ogni altro evento catturato
utile al funzionamento corretto dell’applicazione, come il movimento del
puntatore degli altri client o il cambio di colore del pennello.</p>
<h1 id="ch:into">Part 3</h1>
<h2 id="introduzione-e-struttura">Introduzione e struttura</h2>
<p>La terza ed ultima parte dell’assignement 3 consiste nell’utilizzo di
Java RMI per la comunicazione tra diversi client in versione
distribuita. Differentemente dalla parte 2 viene utilizzata
l’invocazione di metodi di client remoti tramite la libreria
<strong>java.rmi</strong>. Consente di astrarre la comunicazione remota,
fornendo un’interfaccia simile a quella delle invocazioni locali, ma con
il supporto per oggetti distribuiti.</p>
<h3 id="server">Server</h3>
<p>Il server crea un registro RMI e registra i servizi remoti. Di
seguito il codice:</p>
<ul>
<li><p><strong>createRegistry()</strong>: crea un registro RMI per
registrare i servizi remoti.</p></li>
<li><p><strong>exportObject()</strong>: esporta gli oggetti remoti per
consentire le chiamate distribuite.</p></li>
<li><p><strong>rebind()</strong>: associa i nomi dei servizi agli stub
remoti.</p></li>
</ul>
<h3 id="modifiche-client">Modifiche Client</h3>
<h4 id="gridservice">GridService</h4>
<p>Gestisce una griglia condivisa, permettendo ai client di:</p>
<ul>
<li><p>Registrarsi per ricevere aggiornamenti.</p></li>
<li><p>Impostare il colore di un pixel specifico.</p></li>
<li><p>Sincronizzare la griglia tra tutti i client.</p></li>
</ul>
<p>Le operazioni register, setPixel e sendGrid vengono invocate in modo
remoto dai client.</p>
<h4 id="brushservice">BrushService</h4>
<p>coordina i pennelli degli utenti, aggiornando la posizione e
sincronizzando i dati tra i client. I metodi che possono essere invocati
in questa classe si limitano alla gestione dei pennelli con chiamate
remote, catturando gli eventi di aggiunta, rimozione e movimento di
pennelli.</p>
<h4 id="pixelart">PixelArt</h4>
<p>La classe estende UnicastRemoteObject, rendendola esportabile come
oggetto remoto, e implementa le interfacce PixelArt e Serializable. Ciò
consente:</p>
<ul>
<li><p>L’utilizzo come oggetto remoto (richiesto per Java RMI).</p></li>
<li><p>La serializzazione per inviare l’oggetto attraverso la
rete.</p></li>
</ul>
<p>Il metodo configuration configura l’oggetto remoto e l’interfaccia
grafica, e stabilisce le connessioni con i servizi remoti. Connessione
ai Servizi RMI:</p>
<div class="sourceCode" id="list:java_code_pxArt" data-language="Java"
data-caption="getRegistry ottiene il registro RMI. lookup recupera i riferimenti agli oggetti remoti registrati."
label="list:java_code_pxArt"><pre class="sourceCode java"><code class="sourceCode java"><span id="list:java_code_pxArt-1"><a href="#list:java_code_pxArt-1" aria-hidden="true" tabindex="-1"></a>   </span>
<span id="list:java_code_pxArt-2"><a href="#list:java_code_pxArt-2" aria-hidden="true" tabindex="-1"></a><span class="bu">Registry</span> registry <span class="op">=</span> <span class="bu">LocateRegistry</span><span class="op">.</span><span class="fu">getRegistry</span><span class="op">(</span><span class="kw">null</span><span class="op">);</span></span>
<span id="list:java_code_pxArt-3"><a href="#list:java_code_pxArt-3" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">.</span><span class="fu">gridService</span> <span class="op">=</span> <span class="op">(</span>GridService<span class="op">)</span> registry<span class="op">.</span><span class="fu">lookup</span><span class="op">(</span><span class="st">&quot;grid&quot;</span><span class="op">);</span></span>
<span id="list:java_code_pxArt-4"><a href="#list:java_code_pxArt-4" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">.</span><span class="fu">brushService</span> <span class="op">=</span> <span class="op">(</span>BrushService<span class="op">)</span> registry<span class="op">.</span><span class="fu">lookup</span><span class="op">(</span><span class="st">&quot;brush&quot;</span><span class="op">);</span></span></code></pre></div>
<p>getRegistry(): Ottiene il registro RMI. lookup(): Recupera i
riferimenti agli oggetti remoti registrati.</p>
</body>
</html>
